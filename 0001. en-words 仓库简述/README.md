# [0001. en-words ä»“åº“ç®€è¿°](https://github.com/Tdahuyou/en-notes/tree/main/0001.%20en-words%20%E4%BB%93%E5%BA%93%E7%AE%80%E8%BF%B0)

- ğŸ“ summary
  - en-words ä»“åº“ä¸­å­˜æ”¾äº†ã€qwerty-learner è‹±æ–‡å•è¯æ•°æ®æºã€‘è§£æåçš„æ‰€æœ‰å•è¯æ•°æ®ã€‚
  - ä»‹ç»äº† en-words ä¸­æ•°æ®çš„æ¥æºã€‚
  - å®Œæ•´çš„ã€qwerty-learner è‹±æ–‡å•è¯æ•°æ®æºã€‘åœ¨ 0003 ä¸­ï¼Œå°† 0003 ä¸­çš„ sources æ•°æ®æ¬è¿åˆ°å’Œè„šæœ¬åŒçº§çš„ sources ç›®å½•ä¸­ï¼Œç„¶åå†æ‰§è¡Œè§£æè„šæœ¬ã€‚

## ğŸ”— links

- https://github.com/kajweb/dict
  - sources ä¸­çš„æ•°æ®æ¥æºäºè¿™ä¸ªä»“åº“ã€‚

## ğŸ“’ ntoes - en-words ç›®å½•è¯´æ˜

- en-words ç›®å½•ä¸‹å­˜æ”¾äº†è§£æåçš„æ‰€æœ‰å•è¯æ•°æ®ã€‚
- å•è¯æŒ‰ç…§ç»Ÿä¸€çš„æ ¼å¼å­˜å‚¨åœ¨ä¸€ä¸ªä¸ª .md æ–‡ä»¶ä¸­ï¼Œå¯ä»¥è¿›è¡ŒäºŒæ¬¡ç¼–è¾‘ï¼Œä¹Ÿå¯ä»¥æ‰©å±•å…¶å®ƒè¯æ±‡ï¼Œæ³¨æ„æ ¼å¼ä¿æŒç»Ÿä¸€å³å¯ã€‚
- å•è¯æ•°æ®æ ¼å¼å¦‚ä¸‹ï¼ˆä»¥ wire å•è¯ä¸ºä¾‹ï¼‰ï¼š
  - é¦–å…ˆæ˜¯å•è¯çš„åç§°
  - ç´§æ¥ç€æ˜¯å•è¯çš„
    - å‘è¨€
    - è¯ä¹‰
    - åŒæ ¹è¯
    - è¿‘ä¹‰è¯
    - çŸ­è¯­
    - ä¾‹å¥

```md
- wire
  - å‘éŸ³
    - è‹± `/waÉªÉ™/`
    - ç¾ `/'waÉªÉš/`
  - è¯ä¹‰
    - n. é‡‘å±ä¸,ç”µçº¿
    - `thin metal in the form of a thread, or a piece of this`
    - v. å®‰è£…ç”µçº¿,å‘ç”µæŠ¥
    - `to send money electronically`
  - åŒæ ¹è¯
    - adj.
      - `wired` æ¥æœ‰ç”µçº¿çš„ï¼›ä»¥é“ä¸å›´èµ·çš„ï¼›æå…¶å…´å¥‹çš„
      - `wireless` æ— çº¿çš„ï¼›æ— çº¿ç”µçš„
      - `wiry` é‡‘å±çº¿åˆ¶çš„ï¼›é‡‘å±ä¸èˆ¬çš„ï¼›åšç¡¬çš„ï¼›ç˜¦é•¿ç»“å®çš„ï¼›ï¼ˆå™ªéŸ³ï¼‰å°–ç»†çš„
    - adv.
      - `wirily` é“ä¸çŠ¶åœ°
    - n.
      - `wireless` æ— çº¿ç”µ
      - `wiring` [ç”µ] æ¥çº¿ï¼Œæ¶çº¿ï¼›çº¿è·¯ï¼›é‡‘å±çº¿ç¼æœ¯
      - `wirer` æ‰“ç”µæŠ¥è€…ï¼›ç”¨é‡‘å±çº¿ç¼ ç»“çš„å·¥äººï¼›ä»¥é“ä¸ç½‘æ•çŒé¸Ÿå…½è€…
      - `wiriness` é“ä¸ä¸€æ ·çš„å½¢çŠ¶
    - v.
      - `wired` ä»¥é‡‘å±ä¸è£…ï¼›æ‰“ç”µæŠ¥ç»™ï¼ˆwireçš„è¿‡å»åˆ†è¯ï¼‰
      - `wiring` è£…ç”µçº¿ï¼ˆwireçš„ç°åœ¨åˆ†è¯ï¼‰
    - vi.
      - `wireless` æ‰“æ— çº¿ç”µæŠ¥ï¼›æ‰“æ— çº¿ç”µè¯
    - vt.
      - `wireless` ç”¨æ— çº¿ç”µæŠ¥ä¸â€¦è”ç³»ï¼›ç”¨æ— çº¿ç”µæŠ¥å‘é€
  - è¿‘ä¹‰è¯
    - n. [ç”µ]ç”µçº¿ï¼›é‡‘å±ä¸ï¼›ç”µæŠ¥
      - `electric cord`
      - `electrical wiring`
    - vi. æ‰“ç”µæŠ¥
      - `telegraph`
  - çŸ­è¯­
    - `steel wire` é’¢ä¸
    - `wire rope` é’¢ä¸ç´¢ï¼›é’¢ç¼†ï¼Œ é’¢ç´¢
    - `wire netting` é“ä¸ç½‘ï¼›é‡‘å±ç½‘
    - `wire rod` çº¿æï¼›ç›˜æ¡ï¼›ç›˜åœ†ï¼›é’¢ä¸ç­‹æ¡
    - `by wire` ç”¨ç”µæŠ¥
    - `wire mesh` é‡‘å±ä¸ç½‘ï¼›é“ä¸ç½‘
    - `hot wire` n. [ç¾ä¿š]å¥½æ¶ˆæ¯ï¼›ï¼ˆä¸ç”¨é’¥åŒ™èµ·åŠ¨ç‚¹ç«è£…ç½®çš„ï¼‰çŸ­è·¯ç‚¹ç«ï¼›å¸¦ç”µç”µçº¿
    - `wire drawing` æ‹”ä¸ï¼›æŠ½ä¸ç°è±¡
    - `copper wire` é“œçº¿
    - `stainless steel wire` ä¸é”ˆé’¢ä¸
    - `electric wire` n. ç”µçº¿
    - `wire in` [æ—§]åŠªåŠ›å·¥ä½œï¼›ç»™â€¦æ¥ä¸Šç”µæºçº¿
    - `wire cutting` ç”µç«èŠ±çº¿åˆ‡å‰²ï¼›é’¢ä¸åˆ‡å¯
    - `steel wire rope` é’¢ä¸ç»³ï¼›é’¢ä¸ç´¢ï¼›é’¢ç¼†
    - `welding wire` ç„Šä¸ï¼›ç„Šæ¡
    - `barbed wire` æœ‰åˆºé“ä¸ç½‘ï¼›æ£˜é“ä¸
    - `iron wire` é“ä¸ï¼›ä½ç¢³é’¢ä¸
    - `live wire` ç”Ÿé¾™æ´»è™çš„äººï¼›é€šç”µçš„ç”µçº¿
    - `enameled wire` [ç“·]æ¼†åŒ…çº¿ï¼›æ¼†åŒ…é“œçº¿
    - `welded wire mesh` ç”µç„Šç½‘ï¼›ç„Šæ¥é’¢ä¸ç½‘
  - ä¾‹å¥
    - `copper wire`
      - é“œä¸
    - `a wire fence`
      - é“ä¸ç½‘
```

- å•è¯çš„æ ¼å¼æ˜¯å‚ç…§æ•°æ®æºä¸­çš„ç»“æ„æ¥å®šä¹‰çš„ã€‚
- ä¿æŒåç»­æ’å…¥çš„æ–°è¯æ±‡æ ¼å¼çš„ç»Ÿä¸€ï¼Œè¿™æ ·åç»­ç¼–å†™ç»Ÿä¸€çš„æ‰¹å¤„ç†è„šæœ¬ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼Œå¯ä»¥å¯¹æ‰€æœ‰è¯æ±‡ç»Ÿä¸€æ•´ç†ã€‚

## ğŸ¤” é—®ï¼šä¸ºä»€ä¹ˆè¦æ–°å»ºä¸€ä¸ª en-words ä»“åº“ï¼Ÿç›´æ¥å°†ç”Ÿæˆçš„å•è¯æ”¾åœ¨å½“å‰çš„ en-notes ä»“åº“ä¸­ä¸è¡Œå—ï¼Ÿ

- en-notes.0001 ä¸­ç”Ÿæˆçš„å•è¯æ•°é‡å¾ˆå¤šï¼ˆè§£æåé»˜è®¤æœ‰ 2w å¤šä¸ªï¼Œåç»­å­¦ä¹ è¿‡ç¨‹ä¸­è¿˜ä¼šä¸æ–­æ–°å¢ï¼‰ï¼Œä½“ç§¯æœ‰ 150 å¤š MBï¼Œå¦‚æœå°†å•è¯æ”¾åœ¨ en-ntoes ä¸­ï¼Œç”±äºå•è¯æ•°æ®å’Œç¬”è®°æ•°æ®æ··åˆåœ¨ä¸€èµ·ï¼Œä¼šå¯¼è‡´å•è¯çš„æŸ¥è¯¢æˆæœ¬å˜é«˜ã€‚
- å°†å’Œç¬”è®°å’Œå•è¯æ•°æ®åˆ†ç¦»å¼€ï¼Œè®© en-words ä»“åº“ä¸­ä»…å­˜æ”¾å•è¯æ–‡ä»¶ï¼Œè¿™æ ·å¯ä»¥å‡å°‘å•è¯çš„æŸ¥è¯¢æˆæœ¬ã€å‡å°‘å•è¯çš„ç»´æŠ¤æˆæœ¬ã€‚å•è¯ç›´æ¥ä¸¢åˆ°æ ¹ç›®å½•ä¸‹ï¼ŒåŒæ—¶è¿˜æœ‰åŠ©äº url çš„æ„å»ºå’Œå¤ç”¨ã€‚

## ğŸ’» demo - æå–æ‰€æœ‰è¯æ±‡çš„è„šæœ¬

```js
/**
 * 1.js
 * 1.js è¿™ä¸ªè„šæœ¬æ˜¯ 24.10.26 æ—¶åŸºäº en.0002 ä¸­çš„ demo/index4.js ç¼–å†™çš„
 * ç”¨äºæå– sources ä¸­çš„æ‰€æœ‰å•è¯ï¼Œå°†å…¶æ±‡æ€»åˆ° results ç›®å½•ä¸­ã€‚
 */
const fs = require('fs')
const path = require('path')

const SPACE_2 = '  ';
/**
 * æºç›®å½•å
 */
const SOURCE_FOLDER_NAME = 'sources'
/**
 * ç›®æ ‡ç›®å½•å
 */
const RESULT_FOLDER_NAME = 'results'

const SUB_TITLE = {
  sentence: 'ä¾‹å¥',
  phone: 'å‘éŸ³',
  usphone: 'ç¾',
  ukphone: 'è‹±',
  syno: 'è¿‘ä¹‰è¯',
  remMethod: 'è®°å¿†',
  relWord: 'åŒæ ¹è¯',
  phrase: 'çŸ­è¯­',
  trans: 'è¯ä¹‰',
}

let sourcesFolderPath = path.join(__dirname, SOURCE_FOLDER_NAME); // sources ç›®å½•çš„ç»å¯¹è·¯å¾„
let resultsFolderPath = path.join(__dirname, RESULT_FOLDER_NAME); // results ç›®å½•çš„ç»å¯¹è·¯å¾„

// åˆ›å»º results ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
if (!fs.existsSync(resultsFolderPath)) {
  fs.mkdirSync(resultsFolderPath, { recursive: true });
}

const JSON_FileList = fs.readdirSync(sourcesFolderPath)
  .filter(p => p.includes('.json'))
  .map(p => path.join(sourcesFolderPath, p)) // sources ç›®å½•ä¸‹æ‰€æœ‰ json æ–‡ä»¶çš„ç»å¯¹è·¯å¾„

for (let i = 0; i < JSON_FileList.length; i++) {
  writeFile(JSON_FileList[i])
}

// å†™å…¥æ–‡ä»¶
function writeFile(file_path) {
  // JSON parse
  let data = JSON.parse(
    `[${fs.readFileSync(file_path, 'utf-8')}]`
    .replaceAll(/}\r\n/g, '},')
    .replaceAll(/},]/g, '}]')
  )

  data.forEach((it, i) => {

    // if (i > 1000) return;
    // if (i > 1000) return;

    if (/[\s-=?()0123456789]/.test(it.headWord)) return;

    const word = it.content.word.content

    let wordStr =
        '- ' +
        it.headWord.replace(/\//g, '\\') +
        '\n' +
        parsePhone(word) +
        parseTrans(word) +
        parseRemMethod(word) +
        parseRelWord(word) +
        parseSyno(word) +
        parsePhrase(word) +
        parseSentence(word);

    fs.writeFileSync(path.join(resultsFolderPath, `./${it.headWord.replace(/\//g, '\\')}.md`), wordStr)
  })
}

/* -- å‘éŸ³éƒ¨åˆ† -- */
function parsePhone(word) {
  return `${SPACE_2}- ${SUB_TITLE.phone}
${SPACE_2}${SPACE_2}- ${SUB_TITLE.ukphone} \`/${word.ukphone}/\`
${SPACE_2}${SPACE_2}- ${SUB_TITLE.usphone} \`/${word.usphone}/\`
`
}

/* -- è¯ä¹‰éƒ¨åˆ† -- */
function parseTrans(word) {
  let text = ''

  // æ‹¼æ¥è¯ä¹‰
  if (word.trans && word.trans.length > 0) {
    const trans = word.trans
    for (let i = 0; i < trans.length; i++) {
      const t = trans[i]
      if (t.pos && t.tranCn) text += `${SPACE_2}${SPACE_2}- ${t.pos}. ${t.tranCn.replace(/\s/g, '')}\n`
      if (t.tranOther) text += `${SPACE_2}${SPACE_2}- \`${t.tranOther}\`\n`
    }
  }

  return `${SPACE_2}- ${SUB_TITLE.trans}
${text}`
}

/* -- è®°å¿†éƒ¨åˆ† -- */
function parseRemMethod(word) {
  return (word.remMethod && word.remMethod.val) ? `${SPACE_2}- ${SUB_TITLE.remMethod}
${SPACE_2}${SPACE_2}- ${word.remMethod.val.trim()}
` : ''
}

/* -- åŒæ ¹è¯éƒ¨åˆ† -- */
function parseRelWord(word) {
  let text = ''

  if (word.relWord && word.relWord.rels && word.relWord.rels.length > 0) {
    const rels = word.relWord.rels
    for (let i = 0; i < rels.length; i++) {
      const r = rels[i];
      text += `${SPACE_2}${SPACE_2}- ${r.pos}.\n`
      text += r.words.map(w => `${SPACE_2}${SPACE_2}${SPACE_2}- \`${w.hwd}\` ${w.tran.trim()}`).join('\n') + '\n'
    }
  }

  return text ? `${SPACE_2}- ${SUB_TITLE.relWord}
${text}` : ''
}

/* -- åŒè¿‘è¯éƒ¨åˆ† -- */
function parseSyno(word) {
  let text = ''

  if (word.syno && word.syno.synos && word.syno.synos.length > 0) {
    const synos = word.syno.synos
    for (let i = 0; i < synos.length; i++) {
      const s = synos[i];
      text += `${SPACE_2}${SPACE_2}- ${s.pos}. ${s.tran}\n`
      text += s.hwds.map(h => `${SPACE_2}${SPACE_2}${SPACE_2}- \`${h.w}\``).join('\n') + '\n'
    }
  }

  return text ? `${SPACE_2}- ${SUB_TITLE.syno}
${text}` : ''
}

/* -- çŸ­è¯­éƒ¨åˆ† -- */
function parsePhrase(word) {
  let text = ''

  if (word.phrase && word.phrase.phrases) {
    const phrase = word.phrase
    const phrases = phrase.phrases
    phrases.forEach(p => {
      text += `${SPACE_2}${SPACE_2}- \`${p.pContent}\` ${p.pCn} \n`
    })
  }

  return text ? `${SPACE_2}- ${SUB_TITLE.phrase}
${text}` : ''
}

/* -- ä¾‹å¥éƒ¨åˆ† -- */
function parseSentence(word) {
  let text = ''

  if (word.sentence && word.sentence.sentences) {
    const sentence = word.sentence
    const sentences = sentence.sentences
    sentences.forEach(s => {
      text += `${SPACE_2}${SPACE_2}- \`${s.sContent}\`\n${SPACE_2}${SPACE_2}${SPACE_2}- ${s.sCn}` + '\n'
    })
  }

  return text ? `${SPACE_2}- ${SUB_TITLE.sentence}
${text}
` : ''
}

/* ç« èŠ‚è‡ªæµ‹åˆ—è¡¨ */
function generateChapterMD(all_words, result_folder_path) {
  let checkString = '';
  all_words.map((h, i) => {
    const chapterNum = Math.floor(i / 20 + 1);
    if (i % 20 === 0) return `\n# Chapter ${chapterNum.toString().padStart(3, '0')}\n\n` + `- [ ] ${h}\n`
    else return `- [ ] ${h}\n`
  }).forEach((w, i) => {
    const chapterNum = Math.floor(i / 20 + 1);
    checkString += w;
    if (chapterNum % 10 === 0 && i === chapterNum * 20 - 1) {
      fs.writeFileSync(path.join(result_folder_path, `./${(chapterNum - 9).toString().padStart(3, '0')}~${chapterNum.toString().padStart(3, '0')}.md`), checkString)
      checkString = '';
    }
    if (i === all_words.length - 1) {
      fs.writeFileSync(path.join(result_folder_path, `./${(Math.floor(chapterNum / 10) * 10 + 1).toString().padStart(3, '0')}~${chapterNum.toString().padStart(3, '0')}.md`), checkString)
      checkString = '';
    }
  });
}

function clearResultFolder(result_folder_path) {
  emptyDir(result_folder_path)
  rmEmptyDir(result_folder_path)
  fs.mkdirSync(result_folder_path)
}

/**
 * åˆ é™¤æ‰€æœ‰çš„æ–‡ä»¶(å°†æ‰€æœ‰æ–‡ä»¶å¤¹ç½®ç©º)
 * @param {*} filePath
 */
function emptyDir(filePath) {
  try {
    const files = fs.readdirSync(filePath) // è¯»å–è¯¥æ–‡ä»¶å¤¹
    files.forEach((file) => {
      const nextFilePath = `${filePath}/${file}`
      const states = fs.statSync(nextFilePath)
      if (states.isDirectory()) {
        emptyDir(nextFilePath)
      } else {
        fs.unlinkSync(nextFilePath)
        // console.log(`åˆ é™¤æ–‡ä»¶ ${nextFilePath} æˆåŠŸ`)
      }
    })
  } catch (error) {
    // console.log(error)
    return
  }
}

/**
 * åˆ é™¤æ‰€æœ‰çš„ç©ºæ–‡ä»¶å¤¹
 * @param {*} filePath
 */
function rmEmptyDir(filePath) {
  try {
    const files = fs.readdirSync(filePath)
    if (files.length === 0) {
      fs.rmdirSync(filePath)
      // console.log(`åˆ é™¤ç©ºæ–‡ä»¶å¤¹ ${filePath} æˆåŠŸ`)
    } else {
      let tempFiles = 0
      files.forEach((file) => {
        tempFiles++
        const nextFilePath = `${filePath}/${file}`
        rmEmptyDir(nextFilePath)
      })
      //åˆ é™¤æ¯æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰å­—ç©ºæ–‡ä»¶å¤¹åï¼Œå°†æ¯æ–‡ä»¶å¤¹ä¹Ÿåˆ é™¤
      if (tempFiles === files.length) {
        fs.rmdirSync(filePath)
        // console.log(`åˆ é™¤ç©ºæ–‡ä»¶å¤¹ ${filePath} æˆåŠŸ`)
      }
    }
  } catch (error) {
    // console.log(error)
    return
  }
}
```